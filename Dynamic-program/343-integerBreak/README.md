# 343. 整数拆分

[点此跳转题目链接](https://leetcode.cn/problems/integer-break/description/)

## 题目描述

给定一个正整数 `n` ，将其拆分为 `k` 个 **正整数** 的和（ `k >= 2` ），并使这些整数的乘积最大化。

返回 *你可以获得的最大乘积* 。

 

**示例 1:**

```
输入: n = 2
输出: 1
解释: 2 = 1 + 1, 1 × 1 = 1。
```

**示例 2:**

```
输入: n = 10
输出: 36
解释: 10 = 3 + 3 + 4, 3 × 3 × 4 = 36。
```

 

**提示:**

- `2 <= n <= 58`



## 题解

动态规划解决——虽然它的重叠子问题可能不那么明显。

对于任意一个数 $n$ ，将其拆分时，我们可以先确定拆出来的某个正整数为 $m$ ，则剩下的部分为 $n - m$ ；而剩下的这部分 $n - m$ ，我们可以直接将它与 $m$ 相乘，也可以将它拆分后、用拆分后的乘积再与 $m$ 相乘——显然，为了得到最终的最大乘积，我们应该哪个大取哪个。

> 注意，不一定拆分后的结果一定会更大。例如，如果此处 $n - m = 3$ ，若拆分只能拆为 $1 + 2$ 或 $1 + 1 + 1$ ，再求乘积为 $2$ 或 $1$ ，都不如 $3$ 本身大。

于是我们可以确定：

- `dp` 数组的含义： `dp[i]` 表示将 `i` 拆分能得到的最大乘积

- 初始化：参数最小值 $2$ 只能拆成 $1 + 1$ ，求积为 $1$ ，即 `dp[2] = 1` 

- 状态转移方程： `dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]))`  ，其中 `0 < j < i - 1`

  > 这里理论上应该是 `0 < j < i` ，但是当 `j = i - 1` 时，相当于剩下的部分 `i - j` 为1，而1是不可拆分的，相当于重复了一开始 `j = 1` 时的情况，所以实际上可以将其省略。

**代码（C++）**

```cpp
int integerBreak(int n)
{
    vector<int> dp(n + 1);
    dp[2] = 1;
    for (int i = 3; i <= n; ++i) {
        for (int j = 1; j < i - 1; ++j) 
            dp[i] = max(dp[i], max(j * (i - j), j * dp[i - j]));
    }
    return dp[n];
}
```

