# 188. 买卖股票的最佳时机 IV

[点此跳转题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iv/)

## 题目描述

给你一个整数数组 `prices` 和一个整数 `k` ，其中 `prices[i]` 是某支给定的股票在第 `i` 天的价格。

设计一个算法来计算你所能获取的最大利润。你最多可以完成 `k` 笔交易。也就是说，你最多可以买 `k` 次，卖 `k` 次。

**注意：** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1：**

```
输入：k = 2, prices = [2,4,1]
输出：2
解释：在第 1 天 (股票价格 = 2) 的时候买入，在第 2 天 (股票价格 = 4) 的时候卖出，这笔交易所能获得利润 = 4-2 = 2 。
```

**示例 2：**

```
输入：k = 2, prices = [3,2,6,5,0,3]
输出：7
解释：在第 2 天 (股票价格 = 2) 的时候买入，在第 3 天 (股票价格 = 6) 的时候卖出, 这笔交易所能获得利润 = 6-2 = 4 。
     随后，在第 5 天 (股票价格 = 0) 的时候买入，在第 6 天 (股票价格 = 3) 的时候卖出, 这笔交易所能获得利润 = 3-0 = 3 。
```

 

**提示：**

- `1 <= k <= 100`
- `1 <= prices.length <= 1000`
- `0 <= prices[i] <= 1000`



## 题解

股票问题的升级版，仍然用**动态规划**解决，多添加几个状态即可。 这题和 [123. 买卖股票的最佳时机 III](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/description/) 长得很像，只不过那题是最多可以完成**两笔**交易，而本题是最多**k笔** 。参考我之前的 [123-题解](https://blog.csdn.net/weixin_54468359/article/details/141615047?spm=1001.2014.3001.5501) ，我们只需要扩展一下 `dp` 数组即可将同样的套路用到本题。

- `dp` 数组含义： `dp[i][j]` 表示第 `i` 天，不同状态下的余额（初始为0），其中

  - `j = 1` 表示 **第1次** **持有** 股票， `j = 2` 表示 **第1次** **不持有** 股票

  - `j = 3` 表示 **第2次** **持有** 股票， `j = 4` 表示 **第2次** **不持有** 股票

  - ...

  - `j = 2k - 1` 表示**第k次 持有** 股票， `j = 2k` 表示 **第k次 不持有** 股票。

    > 奇数：持有；偶数：不持有
    >
    > :warning: 注意这里表示的是某天是否持有股票的状态，并不意味着一定就在这天买入或卖出了股票

- 状态转移方程：

  - 持有： `dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);` 

    > 维持前一天的持有状态，或者前一天不持有、这天买入。选余额大的。

  - 不持有： `dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);` 

    > 维持前一天的不持有状态，或者前一天持有、这天卖出。选余额大的。

整体代码按照股票问题的动态规划套路写就可以了，具体参见我写的 [CSDN博客-股票问题 I](https://blog.csdn.net/weixin_54468359/article/details/141615047?spm=1001.2014.3001.5501) 或 Carl的 [代码随想录-188](https://programmercarl.com/0188.买卖股票的最佳时机IV.html#算法公开课) 。

**代码（C++）**

```cpp
int maxProfit(int k, vector<int> &prices)
{
    vector<vector<int>> dp(prices.size(), vector<int>(2 * k + 1, 0));

    // 奇数：持有；偶数：不持有
    for (int j = 0; j < 2 * k; j += 2) 
        dp[0][j + 1] = -prices[0];

    for (int i = 1; i < prices.size(); ++i) {
        for (int j = 0; j < 2 * k - 1; j += 2) {
            dp[i][j + 1] = max(dp[i - 1][j + 1], dp[i - 1][j] - prices[i]);
            dp[i][j + 2] = max(dp[i - 1][j + 2], dp[i - 1][j + 1] + prices[i]);
        }
    }

    return dp.back().back();
}
```

