# 300. 最长递增子序列

[点此跳转题目链接](https://leetcode.cn/problems/longest-increasing-subsequence/description/)

## 题目描述

给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

**子序列** 是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。



**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

**示例 2：**

```
输入：nums = [0,1,0,3,2,3]
输出：4
```

**示例 3：**

```
输入：nums = [7,7,7,7,7,7,7]
输出：1
```

 

**提示：**

- `1 <= nums.length <= 2500`
- `-104 <= nums[i] <= 104`

 

**进阶：**

- 你能将算法的时间复杂度降低到 `O(n log(n))` 吗?



## 题解

### 动态规划

这题是**动态规划**中**子序列问题**的基本形式，老样子，首先确定：

- `dp` 数组含义： `dp[i]` 表示原数组里以 `nums[i]` 结尾的（前缀）子数组中，最长递增子序列的长度。
- 状态转移方程：对于 `0 <= j < i` ，如果 `if (nums[i] > nums[j])` ，说明当前的 `nums[i]` 可以加入之前以 `nums[j]` 结尾的递增子序列，得到新递增子序列长度即为 `dp[j] + 1` 。在与原本以 `nums[i]` 为结尾的子序列长度比较，取较大值即可： `dp[i] = max(dp[i], dp[j] + 1)` 。

最后，取 `dp` 中最大值即为所求。

> 该算法更详细的解析参见 [代码随想录-300](https://programmercarl.com/0300.最长上升子序列.html#思路) 

**代码（C++）**

```cpp
int lengthOfLIS(vector<int> &nums)
{
    vector<int> dp(nums.size(), 1);
    for (int i = 1; i < nums.size(); ++i) {
        for (int j = 0; j < i; ++j) {
            if (nums[i] > nums[j])
                dp[i] = max(dp[i], dp[j] + 1);
        }
    }
    return *max_element(dp.begin(), dp.end());
}
```

### 贪心算法 + 二分查找

上面的动态规划解法时间复杂度为 $O(n^2)$ ，如果要满足题目进阶要求的 $O(n log{n})$ ，则可以采用**贪心算法**结合**二分查找**解决。

根据题目，我们或产生一种 “感性” 的认识：要让递增子序列尽可能长，它增长的幅度应该尽可能 “缓” ，即每次增加到该子序列 **末尾** 的数字 **虽然要大于前面所有的数（保证递增），但也要尽可能小** ——例如，假设当前递增子序列为 `1, 3, 4` ，在后面加上 `5` 显然比加个 `10000` 更 “有希望” 继续增长下去。

这实际上也就是一种贪心算法的思路。据此，我们维护一个数组 `d[i]` ，表示：**长度为 `i` 的最长递增子序列的末尾元素的最小值** ；用 `len` 记录当前得到的最长递增子序列的长度。显然，初始状态下 `d[1] = nums[0]` ， `len = 1` 。

然后，我们遍历 `nums` 数组：

- 如果 `nums[i] > d[len]` ，即当前遍历到的数字 大于 当前最长的递增子序列的最小末尾值，我们自然可以将其添加到末尾并加长 `len` ，即 `d[++len] = nums[i]` 。
- 否则，在 `d` 数组中找到一个 `d[j]` ，满足 `d[j - 1] < nums[i] < d[j]` ；由于我们是顺序遍历 `nums` ，所以长度为 `j` 的最长子序列的最小末尾元素 `d[j]` 此时需要更新为 `nums[i]` 。

由于 `d` 数组也是单调递增的，上面的第二种情况可以用二分查找快速找到待更新的 `d[j]` 。

> 关于 `d` 数组的单调性，LeetCode官方题解的证明如下（反证法）：
>
> 如果 `d[j] ≥ d[i]` 且 `j < i` ：
>
> 我们考虑从长度为 `i` 的递增子序列的末尾删除 `i − j` 个元素，那么这个序列长度变为 `j` ，且第 `j` 个元素 `x`（末尾元素）必然小于 `d[i]`，也就小于 `d[j]`。
>
> 那么我们就找到了一个长度为 `j` 的递增子序列，并且末尾元素 `x` 比 `d[j]` 小，从而产生了矛盾。
>
> > :bulb: 这与 “ `d[j]` 表示长度为 `j` 的递增子序列的最小末尾元素” 矛盾。
>
> 因此数组 d 的单调性得证。

最后的 `len` 即为所求。

**代码（C++）**

```cpp
int lengthOfLIS(vector<int> &nums)
{
    int len = 1;
    vector<int> d(nums.size() + 1, 0);
    d[1] = nums[0];

    for (int i = 1; i < nums.size(); ++i) {
        if (nums[i] > d[len]) 
            d[++len] = nums[i];
        else {
            // 二分查找：待更新的位置下标j，即d中第一个大于nums[i]的位置
            int left = 1;
            int right = len;
            int j = 1; // 如果找不到，说明d中所有数都比nums[i]大，最后应更新d[1]
            while (left <= right) {
                int mid = left + (right - left) / 2;
                if (d[mid] < nums[i]) {
                    j = mid + 1;
                    left = mid + 1;
                } else 
                    right = mid - 1;
            }
            d[j] = nums[i];
        }
    }
    return len;
}
```

遍历 `nums` 的时间复杂度为 $O(n)$ ，二分查找的时间复杂度为 $O(logn)$ ，因此该算法的时间复杂度为 $O(nlogn)$ 。

### 拓展

在LeetCode题解区还看到一位大哥对本题的深入和延申解法，包括分层 DAG 建模等方法，感觉也很 :cow: :beer: ，参见这篇 [最长递增子序列（nlogn 二分法、DAG 模型 和 延伸问题） | 春水煎茶 (writings.sh)](https://writings.sh/post/longest-increasing-subsequence-revisited#spsr-box) 。