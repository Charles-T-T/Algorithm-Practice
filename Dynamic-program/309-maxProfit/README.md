# 309. 买卖股票的最佳时机含冷冻期

[点此跳转题目链接](https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-cooldown/description/)

## 题目描述

给定一个整数数组`prices`，其中第 `prices[i]` 表示第 `i` 天的股票价格 。

设计一个算法计算出最大利润。在满足以下约束条件下，你可以尽可能地完成更多的交易（多次买卖一支股票）:

- 卖出股票后，你无法在第二天买入股票 (即冷冻期为 1 天)。

**注意：** 你不能同时参与多笔交易（你必须在再次购买前出售掉之前的股票）。

 

**示例 1:**

```
输入: prices = [1,2,3,0,2]
输出: 3 
解释: 对应的交易状态为: [买入, 卖出, 冷冻期, 买入, 卖出]
```

**示例 2:**

```
输入: prices = [1]
输出: 0
```

 

**提示：**

- `1 <= prices.length <= 5000`
- `0 <= prices[i] <= 1000`



## 题解

在 [普通股票问题](https://blog.csdn.net/weixin_54468359/article/details/141615047?spm=1001.2014.3001.5501) 基础上，增加了一个 **“卖出股票的第二天不能买入”** 的冷冻期，实际上也就是增加了一个 `dp` 数组状态——原本是 **持有、不持有** 两种，现在“不持有”要分为 **“不持有但不是当天卖出”** 和 **“当前卖出”** 两种。

- `dp` 数组含义： `dp[i][j]` 表示第 `i` 天，不同状态下的余额（初始为0），其中
  - `j = 0` 表示 **不持有但不是当天卖出** 股票
  - `j = 1` 表示 **持有** 股票
  - `j = 2` 表示 **当天卖出** 股票

- 状态转移方程：

  - 不持有但不是当天卖出： `dp[i][0] = max(dp[i - 1][0], dp[i - 1][2])` 

    > 不是当天卖出，故只考虑之前也不持有的两种情况即可，取余额大的。

  - 持有： `dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);` 

    > 经典的状态转移：维持前一天的持有状态，或前一天不持有、这天买入，取余额大的。

  - 当天卖出： `dp[i - 1][1] + prices[i]` 

结果即为最后一天，不持有的两种状态中余额更高的那个。

> 本题更详细的解析参见 [代码随想录-309](https://programmercarl.com/0309.最佳买卖股票时机含冷冻期.html#思路) ，不过其中算法设了4种状态（比我多一种），但原理相通。

**代码（C++）**

```cpp
int maxProfit(vector<int> &prices)
{
    vector<vector<int>> dp(prices.size(), vector<int>(3));

    // 0：不持有但不是当天卖出
    // 1：持有
    // 2：当天卖出
    dp[0][1] = -prices[0];
    for (int i = 1; i < prices.size(); ++i) {
        dp[i][0] = max(dp[i - 1][0], dp[i - 1][2]);
        dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i]);
        dp[i][2] = dp[i - 1][1] + prices[i];
    }

    return max(dp.back()[0], dp.back()[2]);
}
```

