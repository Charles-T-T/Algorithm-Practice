# 279. 完全平方数

[点此跳转题目链接](https://leetcode.cn/problems/perfect-squares/description/)

## 题目描述

给你一个整数 `n` ，返回 *和为 `n` 的完全平方数的最少数量* 。

**完全平方数** 是一个整数，其值等于另一个整数的平方；换句话说，其值等于一个整数自乘的积。例如，`1`、`4`、`9` 和 `16` 都是完全平方数，而 `3` 和 `11` 不是。

 

**示例 1：**

```
输入：n = 12
输出：3 
解释：12 = 4 + 4 + 4
```

**示例 2：**

```
输入：n = 13
输出：2
解释：13 = 4 + 9
```

 

**提示：**

- `1 <= n <= 104`



## 题解

由题可知，拆分出来的完全平方数是可以重复的，所以这是个 **完全背包问题** ；同时，题目要求的是完全平方数的个数，也就是求组合数，故按照常规的 **先遍历物品、再遍历背包大小** 的顺序 **动态规划** 即可解决。

- `dp` 数组含义： `dp[j]` 表示和为 `j` 的完全平方数的最少数量

- 状态转移方程： `dp[j] = min(dp[j], dp[j - pow(i, 2)] + 1)` 

  > 考虑一个新的完全平方数 `pow(i, 2)` （ `i` 的平方），如果加上它恰好凑成 `j` ，则之前的和为 `j - pow(i, 2)` ，彼时所用的最少完全平方数个数为 `dp[j - pow(i, 2)]` ；加上新的这个数，所用完全平方数个数为 `dp[j - pow(i, 2)] + 1` 。然后取这个值和原来的 `dp[j]` 中较小的那个。

:warning: 每次要取 `dp` 最小值，故一开始要将 `dp` 数组中的元素初始化为极大值。

**代码（C++）**

```cpp
int numSquares(int n)
{
    vector<int> dp(n + 1, INT_MAX);
    dp[0] = 0;
    for (int i = 1; pow(i, 2) <= n; ++i) {
        for (int j = pow(i, 2); j <= n; ++j)
            dp[j] = min(dp[j], dp[j - pow(i, 2)] + 1);
    }
    return dp[n];
}
```

