# 377. 组合总和 IV

[点此跳转题目链接](https://leetcode.cn/problems/combination-sum-iv/description/)

## 题目描述

给你一个由 **不同** 整数组成的数组 `nums` ，和一个目标整数 `target` 。请你从 `nums` 中找出并返回总和为 `target` 的元素组合的个数。

题目数据保证答案符合 32 位整数范围。

 

**示例 1：**

```
输入：nums = [1,2,3], target = 4
输出：7
解释：
所有可能的组合为：
(1, 1, 1, 1)
(1, 1, 2)
(1, 2, 1)
(1, 3)
(2, 1, 1)
(2, 2)
(3, 1)
请注意，顺序不同的序列被视作不同的组合。
```

**示例 2：**

```
输入：nums = [9], target = 3
输出：0
```

 

**提示：**

- `1 <= nums.length <= 200`
- `1 <= nums[i] <= 1000`
- `nums` 中的所有元素 **互不相同**
- `1 <= target <= 1000`

 

**进阶：** 如果给定的数组中含有负数会发生什么？问题会产生何种变化？如果允许负数出现，需要向题目中添加哪些限制条件？



## 题解

这题乍一看和 [之前的几个组合问题](https://blog.csdn.net/weixin_54468359/article/details/140798384?spm=1001.2014.3001.5501) 差不多，但是用同样的回溯算法解决容易超时。我们可以将其转化为一个 **完全背包问题** ，然后用动态规划解决：

**用 `weights` 为 `nums` 的物品，恰好装满容量为 `target` 的背包（物品的使用次数不限），共有多少种方法？**

这样看似乎和 [518. 零钱兑换 II](https://leetcode.cn/problems/coin-change-ii/description/) 一样，但是注意这题说了 “顺序不同的序列被视作不同的组合” ，即实质上这是个 **排列** 问题，而非518那样的 **组合** 问题。不过算法的框架都是相同的：

- `dp` 数组的含义： `dp[j]` 表示用 `nums` 凑出总和 `j` 一共有 `dp[j]` 种方法
- 状态转移方程：对于容量为 `j` 的背包，考虑一个新的 `nums[i]` ，如果把它装进去（相应的可能要拿出其他物品，即对应 `dp[j - nums[i]]` ）恰好装满，则自然新增了 `dp[j - nums[i]]` 种方法，所以有 `dp[j] += dp[j - nums[i]]` 

:warning: 需要注意的是，一般求 **组合** 的完全背包问题是 **先遍历物品、再遍历容量** ，而像本题这样求 **排列** 的完全背包问题应该 **先遍历容量、再遍历物品** 。简单来说，可以理解为这样每次对于新的容量，都会从头考虑一遍所有物品（这就自然包含了使用过的）， 从而实现不同的排列。

> 该算法更详细的讲解参见 [代码随想录](https://programmercarl.com/0377.组合总和Ⅳ.html#思路)

**代码（C++）**

```cpp
int combinationSum4(vector<int> &nums, int target)
{
    vector<long long> dp(target + 1, 0);
    dp[0] = 1;
    for (int j = 1; j <= target; ++j) {
        for (int num : nums) {
            if (j >= num && INT_MAX - dp[j] > dp[j - num])
                dp[j] += dp[j - num];
        }
    }
    return dp[target];
}
```

> LeetCode的测试用例中有 `int` 越界的情况，所以要先检查 `INT_MAX - dp[j] > dp[j - num]` 。
>
> 我也尝试用 `long long` ，仍越界。不过这样直接把越界情况删掉感觉也不是最合理的，毕竟那对应的虽然是极大的排列种数，但这些排列仍是正确合理的。大抵是测试用例设计的问题，因为看了下官方题解也是这么做的。