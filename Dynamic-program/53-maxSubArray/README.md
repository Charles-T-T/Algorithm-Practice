# 53. 最大子数组和

[点此跳转题目链接](https://leetcode.cn/problems/maximum-subarray/description/)

## 题目描述

给你一个整数数组 `nums` ，请你找出一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

**子数组**是数组中的一个连续部分（**连续的** **非空** **元素序列**）。



**示例 1：**

```
输入：nums = [-2,1,-3,4,-1,2,1,-5,4]
输出：6
解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。
```

**示例 2：**

```
输入：nums = [1]
输出：1
```

**示例 3：**

```
输入：nums = [5,4,-1,7,8]
输出：23
```

 

**提示：**

- `1 <= nums.length <= 105`
- `-104 <= nums[i] <= 104`

 

**进阶： ** 如果你已经实现复杂度为 `O(n)` 的解法，尝试使用更为精妙的 **分治法** 求解。



## 题解

### 动态规划

简单的**一维动态规划**问题。

- `dp` 数组的含义： `dp[i]` 表示 `nums[0...i]` 里的最大子数组和

- 状态转移方程：由于子数组是 **连续的** ， `dp[i]` 显然只由两种状态得来：

  - 将 `nums[i]` 接在以 `nums[i - 1]` 为结尾的子数组后面，长度为 `dp[i - 1] + 1` 
  - 自立门户，将 `nums[i]` 作为新子数组的开头，长度为1

  取最大值，即 `dp[i] = max(dp[i - 1] + nums[i], nums[i])` 。

最后，看以哪个元素为结尾的最大子数组和最大即可。

**代码（C++）**

```cpp
int maxSubArray(vector<int> &nums)
{
    vector<int> dp(nums.size());
    dp[0] = nums[0];
    for (int i = 1; i < nums.size(); ++i) {
        dp[i] = max(dp[i - 1] + nums[i], nums[i]);
    }
    return *max_element(dp.begin(), dp.end());
}
```

### 分治法

上面算法的时间复杂度为 $O(n)$ 。不过，题目的进阶要求提示我们可以用 **分治法** ，实现一个更 “有趣” 的算法如下：

> :link: 以下内容基本摘自 [LeetCode官方题解](https://leetcode.cn/problems/maximum-subarray/solutions/228009/zui-da-zi-xu-he-by-leetcode-solution/)  

这个分治方法类似于「线段树求解最长公共上升子序列问题」的 `pushUp` 操作。 也许读者还没有接触过线段树，没有关系，方法二的内容假设你没有任何线段树的基础。当然，如果读者有兴趣的话，推荐阅读线段树区间合并法解决多次询问的**「区间最长连续上升序列问题」**和**「区间最大子段和问题」**，还是非常有趣的。

我们定义一个操作 `get(a, l, r)` 表示查询 $a$ 序列 $[l, r]$ 区间内的最大子段和，那么最终我们要求的答案就是 `get(nums, 0, nums.size() - 1)` 。

如何分治实现这个操作呢？对于一个区间 $[l, r]$ ，我们取 $m =  \frac{l+r}{2}$ ，对区间 $[l,m]$ 和 $[m+1,r]$ 分治求解。当递归逐层深入直到区间长度缩小为 $1$ 的时候，递归「开始回升」。

这个时候我们考虑如何通过 $[l,m]$ 区间的信息和 $[m+1,r]$ 区间的信息合并成区间 $[l,r]$ 的信息。最关键的两个问题是：

- 我们要维护区间的哪些信息呢？
- 我们如何合并这些信息呢？

对于一个区间 $[l,r]$ ，我们可以维护四个量：

- $lSum$ 表示 $[l,r]$ 内以 $l$ 为左端点的最大子段和
- $rSum$ 表示 $[l,r]$ 内以 $r$ 为右端点的最大子段和
- $mSum$ 表示 $[l,r]$ 内的最大子段和
- $iSum$ 表示 $[l,r]$ 的区间和

以下简称 $[l,m]$ 为 $[l,r]$ 的「左子区间」， $[m+1,r]$ 为 $[l,r]$ 的「右子区间」。我们考虑如何维护这些量呢（如何通过左右子区间的信息合并得到 $[l,r]$ 的信息）？对于长度为 $1$ 的区间 $[i,i]$，四个量的值都和 `nums[i]` 相等。对于长度大于 $1$ 的区间：

- 首先最好维护的是 $iSum$，区间 $[l,r]$ 的 $iSum$ 就等于「左子区间」的 $iSum$ 加上「右子区间」的 $iSum$。
- 对于 $[l,r]$ 的 $lSum$，存在两种可能，它要么等于「左子区间」的 $lSum$，要么等于「左子区间」的 $iSum$ 加上「右子区间」的 $lSum$，二者取大。
- 对于 $[l,r]$ 的 $rSum$ ，同理，它要么等于「右子区间」的 $rSum$ ，要么等于「右子区间」的 $iSum$ 加上「左子区间」的 $rSum$ ，二者取大。
- 当计算好上面的三个量之后，就很好计算 $[l,r]$ 的 $mSum$ 了。我们可以考虑 $[l,r]$ 的 $mSum$ 对应的区间是否跨越 $m$ ——它可能不跨越 $m$ ，也就是说 $ [l,r]$ 的 $mSum$ 可能是「左子区间」的 $mSum$ 和 「右子区间」的 $mSum$ 中的一个；它也可能跨越 $m$ ，可能是「左子区间」的 $rSum$ 和 「右子区间」的 $lSum$ 求和。三者取大。

这样问题就得到了解决。

**代码（C++）**

```cpp
class Solution // 分治法
{
private:
    struct Status {
        int lSum;
        int rSum;
        int mSum;
        int iSum;    
    };

    Status pushUp(Status l, Status r) {
        int iSum = l.iSum + r.iSum;
        int lSum = max(l.lSum, l.iSum + r.lSum);
        int rSum = max(r.rSum, l.rSum + r.iSum);
        int mSum = max(max(l.mSum, r.mSum), l.rSum + r.lSum);
        return Status{lSum, rSum, mSum, iSum};
    }

    Status get(const vector<int>& a, int l, int r) {
        if (l == r)
            return Status{a[l], a[l], a[l], a[l]};

        int m = l + (r - l) / 2;
        Status left = get(a, l, m);
        Status right = get(a, m + 1, r);
        
        return pushUp(left, right);
    }

public:
    int maxSubArray(vector<int> &nums)
    {
        return get(nums, 0, nums.size() - 1).mSum;
    }
};
```

**复杂度分析**

假设序列 $a$ 的长度为 $n$ 。

- 时间复杂度：假设我们把递归的过程看作是一颗二叉树的先序遍历，那么这颗二叉树的深度的渐进上界为  $O(logn)$ ，这里的总时间相当于遍历这颗二叉树的所有节点，故总时间的渐进上界是 $O(\sum_{i=1}^{log{n}} 2^{i-1}) = O(n)$ ，故渐进时间复杂度为 $O(n)$ 。
- 空间复杂度：递归会使用 $O(logn)$ 的栈空间，故渐进空间复杂度为 $O(logn)$ 。

**题外话**

「方法二」相较于「方法一」来说，时间复杂度相同，但是因为使用了递归，并且维护了四个信息的结构体，运行的时间略长，空间复杂度也不如方法一优秀，而且难以理解。那么这种方法存在的意义是什么呢？

对于这道题而言，确实是如此的。但是仔细观察「方法二」，它不仅可以解决区间 $[0,n−1]$ ，还可以用于解决任意的子区间 $[l,r]$ 的问题。如果我们把 $[0,n−1]$ 分治下去出现的所有子区间的信息都用堆式存储的方式记忆化下来，即建成一棵真正的树之后，我们就可以在 $O(logn)$ 的时间内求到任意区间内的答案，我们甚至可以修改序列中的值，做一些简单的维护，之后仍然可以在 $O(logn)$ 的时间内求到任意区间内的答案，对于大规模查询的情况下，这种方法的优势便体现了出来。这棵树就是上文提及的一种神奇的数据结构——**线段树**。

