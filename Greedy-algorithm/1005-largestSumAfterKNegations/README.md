# 1005. K次取反后最大化的数组

[点此跳转题目链接](https://leetcode.cn/problems/maximize-sum-of-array-after-k-negations/description/)

## 题目描述

给你一个整数数组 `nums` 和一个整数 `k` ，按以下方法修改该数组：

- 选择某个下标 `i` 并将 `nums[i]` 替换为 `-nums[i]` 。

重复这个过程恰好 `k` 次。可以多次选择同一个下标 `i` 。

以这种方式修改数组后，返回数组 **可能的最大和** 。

 

**示例 1：**

```
输入：nums = [4,2,3], k = 1
输出：5
解释：选择下标 1 ，nums 变为 [4,-2,3] 。
```

**示例 2：**

```
输入：nums = [3,-1,0,2], k = 3
输出：6
解释：选择下标 (1, 2, 2) ，nums 变为 [3,1,0,2] 。
```

**示例 3：**

```
输入：nums = [2,-3,-1,5,-4], k = 2
输出：13
解释：选择下标 (1, 4) ，nums 变为 [2,3,-1,5,4] 。
```

 

**提示：**

- `1 <= nums.length <= 104`
- `-100 <= nums[i] <= 100`
- `1 <= k <= 104`



## 题解

典型的贪心算法。很容易想到，要让和最大，就要“贪心”地把原数组中的负数取反，变成正数。然后考虑一些细节问题：

- 如果 `k` 小于原数组中的负数个数，则应该让最小的k个负数取反，得到的“正收益”自然最大
- 如果 `k` 大于原数组中的负数个数，意味着将原数组中所有负数（如果有的话）取反后，还“不得不”对已经全是非负数的新数组进行 `k'` 次取反（ `k'` 为剩余的取反次数）
  - 如果 `k'` 为偶数，由于对任何数取反偶数次相当于没变，可以忽略此种情况
  - 如果 `k'` 为奇数，同上，相当于要对某个数取反1次，自然我们要找此时新数组（全为非负数）中最小的数取反，这样才能将“损耗”降到最低

**代码（C++）**

```cpp
int largestSumAfterKNegations(vector<int> &nums, int k)
{
    // 贪心：尽量把小的负数取反，变成正数
    sort(nums.begin(), nums.end(), [](int a, int b){return abs(a) > abs(b);});
    int sum = 0;
    for (int &num : nums) {
        if (num < 0 && k > 0) {
            num = -num;
            k--;
        }
        sum += num;
    }
    if (k % 2 == 1)
        sum -= 2 * nums.back();
    return sum;
}
```

> 一开始直接按照绝对值从大到小对原数组排序，这样，负数全取反后，新数组的最后一个数 `nums.back()` 就是此时的最小值；之后若需要将其取反，就相当于数组和 `sum` 减去两次该值。